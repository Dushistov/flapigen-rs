
#[derive(Clone, PartialEq, Eq)]
pub struct TestClass {
    i: i32,
}

impl TestClass {
    pub fn new() -> TestClass {
        TestClass { i: 0 }
    }

    pub fn increment(&mut self) {
        self.i += 1;
    }

    pub fn add(&mut self, i: i32) {
        self.i += i;
    }

    pub fn add_ref(&mut self, i: &i32) {
        self.i += *i;
    }

    pub fn maybe_add(&mut self, i: Option<i32>) -> Option<i32> {
        if let Some(i) = i {
            self.i += i;
            Some(self.i)
        } else {
            None
        }
    }

    pub fn print(&self) {
        println!("TestClass::i: {}", self.i)
    }

    pub fn format(&self) -> String {
        format!("TestClass::i: {}", self.i)
    }

    pub fn get(&self) -> i32 {
        self.i
    }

    pub fn get_ref(&self) -> &i32 {
        &self.i
    }
}

#[derive(Clone)]
pub struct TestClass2 {
    t: TestClass,
}

impl TestClass2 {
    pub fn new(t: TestClass) -> TestClass2 {
        Self {
            t
        }
    }
    pub fn set_option_ref(&mut self, t: Option<&TestClass>) {
        if let Some(t) = t {
            self.t = t.clone();
        }
    }

    pub fn option_ref(&self) -> Option<&TestClass> {
        Some(&self.t)
    }
}

impl std::ops::Drop for TestClass {
    fn drop(&mut self) {
        println!("Dropping!");
    }
}

foreigner_class!(
    #[derive(Clone)]
    /// Test class containing standard methods.
    class TestClass {
        self_type TestClass;
        /// Documentation for constructor
        constructor TestClass::new() -> TestClass;
        /// increment method documentation
        fn TestClass::increment(&mut self);
        fn TestClass::print(&self);
        fn TestClass::add(&mut self, i: i32);
        fn TestClass::get(&self) -> i32;
        fn TestClass::clone(&self) -> TestClass;
        fn TestClass::eq(&self, other: &TestClass) -> bool;
    }
);

foreigner_class!(
    #[derive(Clone)]
    class TestClass2 {
        self_type TestClass2;
        /// Documentation for constructor
        constructor TestClass2::new(t: TestClass) -> TestClass2;
        fn TestClass2::set_option_ref(&mut self, t: Option<&TestClass>);
        fn TestClass2::option_ref(&self) -> Option<&TestClass>;
        fn TestClass2::clone(&self) -> TestClass2;
    }
);


pub struct TestStaticClass {}

impl TestStaticClass {
    pub fn hello() {
        println!("Hello from Rust");
    }

    pub fn print_number(n: i32) {
        println!("print_number: {}", n);
    }

    pub fn add(a: i32, b: i32) -> i32 {
        a + b
    }

    pub fn add_ref(a: &i32, b: &i32) -> i32 {
        a + b
    }

    pub fn concat(a: String, b: String) -> String {
        a + &b
    }

    pub fn concat_str(a: &str, b: &str) -> String {
        a.to_owned() + b
    }

    pub fn test_vec(mut vec: Vec<i32>) -> Vec<i32> {
        for i in vec.iter_mut() {
            *i += 1;
        }
        vec
    }

    pub fn return_class_ref(obj: &TestClass) ->&TestClass {
        obj
    }

    pub fn maybe_return_class(str: Option<String>) -> Option<TestClass> {
        str.map(|_| TestClass::new())
    }

    //pub fn maybe_return_class_ref<'a>(obj: Option<&TestClass>) -> Option<&TestClass> {
    //    obj
    //}

    pub fn maybe_add_one(i: Option<i32>) -> Option<i32> {
        i.map(|i| i + 1)
    }

    pub fn test_obj_by_value(obj: TestClass) {
        obj.print();
    }
}

foreigner_class!(
    /// Test class containing static methods only.
    class TestStaticClass {
        /// Documentation for `TestStaticClass::hello`()
        fn TestStaticClass::hello();
        fn TestStaticClass::print_number(n: i32);
        fn TestStaticClass::add(a: i32, b: i32) -> i32;
        fn TestStaticClass::concat(a: String, b: String) -> String;
        fn TestStaticClass::concat_str(a: &str, b: &str) -> String;
        fn TestStaticClass::test_vec(vec: Vec<i32>) -> Vec<i32>;
        fn TestStaticClass::maybe_return_class(str: Option<String>) -> Option<TestClass>;
        //fn TestStaticClass::maybe_return_class_ref(obj: Option<&TestClass>) -> Option<&TestClass>;
        fn TestStaticClass::return_class_ref(obj: &TestClass) -> &TestClass;
        fn TestStaticClass::maybe_add_one(i: Option<i32>) -> Option<i32>;
        fn TestStaticClass::test_obj_by_value(obj: TestClass);
    }
);
