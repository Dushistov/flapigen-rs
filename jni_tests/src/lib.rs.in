use std::rc::Rc;
use std::cell::RefCell;
use std::path::{Path, PathBuf};
use std::time::SystemTime;

use jni_c_header::{jint, JNIEnv, jclass, jlong, jstring, jdouble, jfloat, jboolean, jobject,
                   jfieldID, jobjectArray, jmethodID, jsize, jshort, jbyte};

#[derive(Clone)]
struct Foo {
    data: i32,
    name: String,
}

impl Foo {
    fn new(val: i32, name: &str) -> Foo {
        println!("name: {}", name);
        Foo {
            data: val,
            name: name.to_string(),
        }
    }

    fn f(&self, a: i32, b: i32) -> i32 {
        self.data + a + b
    }

    fn name(&self) -> &str {
        &self.name
    }

    fn f_double(&self, a: f64, b: f64) -> f64 {
        a.hypot(b) + self.data as f64
    }
}

fn f_hypot(a: f64, b: f64) -> f64 {
    a.hypot(b)
}

fn now() -> SystemTime {
    return SystemTime::now();
}

foreigner_class!(class Foo {
    self_type Foo;
    constructor Foo::new(_: i32, _: &str) -> Foo;
    method Foo::f(&self, _: i32, _: i32) -> i32;  alias calcF;
    method Foo::f_double(&self, _: f64, _: f64) -> f64;
    method Foo::name(&self) -> &str; alias getName;
    static_method f_hypot(_: f64, _: f64) -> f64; alias fHypot;
    static_method now() -> SystemTime;
});

struct Boo {
    a: i32,
}

impl Boo {
    fn new() -> Boo {
        Boo { a: 17 }
    }
    fn test(&self, a: bool) -> f32 {
        if a {
            ::std::f32::consts::E
        } else {
            ::std::f32::consts::PI
        }
    }
    fn set_a(&mut self, val: i32) {
        self.a = val;
    }
    fn get_a(&self) -> i32 {
        self.a
    }
}

fn create_boo() -> Rc<RefCell<Boo>> {
    Rc::new(RefCell::new(Boo::new()))
}

fn test_u8(v: u8) -> u8 {
    v + 1
}

fn test_i8(v: i8) -> i8 {
    v + 1
}

fn test_u16(v: u16) -> u16 {
    v + 1
}

fn test_i16(v: i16) -> i16 {
    v + 1
}

fn test_i32(v: i32) -> i32 {
    v + 1
}

fn test_u32(v: u32) -> u32 {
    v + 1
}

fn test_u64(v: u64) -> u64 {
    v + 1
}

fn test_i64(v: i64) -> i64 {
    v + 1
}

fn test_f32(v: f32) -> f32 {
    v + 1.
}
fn test_f64(v: f64) -> f64 {
    v + 1.
}

fn r_test_u8(v: u8) -> Result<u8, &'static str> {
    Ok(v + 1)
}

fn r_test_i8(v: i8) -> Result<i8, &'static str> {
    Ok(v + 1)
}

fn r_test_u16(v: u16) -> Result<u16, &'static str> {
    Ok(v + 1)
}

fn r_test_i16(v: i16) -> Result<i16, &'static str> {
    Ok(v + 1)
}

fn r_test_i32(v: i32) -> Result<i32, &'static str> {
    Ok(v + 1)
}

fn r_test_u32(v: u32) -> Result<u32, &'static str> {
    Ok(v + 1)
}

fn r_test_u64(v: u64) -> Result<u64, &'static str> {
    Ok(v + 1)
}

fn r_test_i64(v: i64) -> Result<i64, &'static str> {
    Ok(v + 1)
}

fn r_test_f32(v: f32) -> Result<f32, &'static str> {
    Ok(v + 1.)
}
fn r_test_f64(v: f64) -> Result<f64, &'static str> {
    Ok(v + 1.)
}


foreigner_class!(class Boo {
    self_type Boo;
    constructor create_boo() -> Rc<RefCell<Boo>>;
    method Boo::test(&self, _: bool) -> f32;
    method Boo::set_a(&mut self, _: i32); alias setA;
    method Boo::get_a(&self) -> i32; alias getA;
    static_method test_u8(v: u8) -> u8;
    static_method test_i8(v: i8) -> i8;
    static_method test_u16(v: u16) -> u16;
    static_method test_i16(v: i16) -> i16;
    static_method test_i32(v: i32) -> i32;
    static_method test_u32(v: u32) -> u32;
    static_method test_u64(v: u64) -> u64;
    static_method test_i64(v: i64) -> i64;
    static_method test_f32(v: f32) -> f32;
    static_method test_f64(v: f64) -> f64;


    static_method r_test_u8(v: u8) -> Result<u8, &'static str>;
    static_method r_test_i8(v: i8) -> Result<i8, &'static str>;
    static_method r_test_u16(v: u16) -> Result<u16, &'static str>;
    static_method r_test_i16(v: i16) -> Result<i16, &'static str>;
    static_method r_test_i32(v: i32) -> Result<i32, &'static str>;
    static_method r_test_u32(v: u32) -> Result<u32, &'static str>;
    static_method r_test_u64(v: u64) -> Result<u64, &'static str>;
    static_method r_test_i64(v: i64) -> Result<i64, &'static str>;
    static_method r_test_f32(v: f32) -> Result<f32, &'static str>;
    static_method r_test_f64(v: f64) -> Result<f64, &'static str>;
});

struct TestPathAndResult {
    path: PathBuf,
    boo: Rc<RefCell<Boo>>,
}

impl TestPathAndResult {
    fn empty() -> Result<TestPathAndResult, String> {
        println!("TestPathAndResult::empty");
        Err("test error path".into())
    }
    fn new(path: &Path) -> Result<TestPathAndResult, String> {
        println!("TestPathAndResult::new path: {:?}", path);
        Ok(TestPathAndResult {
               path: path.into(),
               boo: create_boo(),
           })
    }

    fn get_path(&self) -> String {
        self.path.to_str().unwrap().into()
    }

    fn get_boo(&self) -> Rc<RefCell<Boo>> {
        self.boo.clone()
    }

    fn get_foo_list(&self) -> Vec<Foo> {
        let mut ret = Vec::new();
        for i in 0..10 {
            ret.push(Foo::new(i, &format!("foo arr: {}", i)));
        }
        ret
    }
}

foreigner_class!(class TestPathAndResult {
    self_type TestPathAndResult;
    constructor TestPathAndResult::empty() -> Result<TestPathAndResult, String>;
    constructor TestPathAndResult::new(path: &Path) -> Result<TestPathAndResult, String>;
    method TestPathAndResult::get_path(&self) -> String; alias getPath;
    method TestPathAndResult::get_boo(&self) -> Rc<RefCell<Boo>>; alias getBoo;
    foreigner_code "    public int javaFunc() { return 17; }\n";
    foreigner_code r#"
    public Boo[] testHandArrayReturn() { return do_testHandArrayReturn(this.mNativeObj); }
    private static native Boo[] do_testHandArrayReturn(long me);
"#;
    method TestPathAndResult::get_foo_list(&self) -> Vec<Foo>;
});

#[allow(non_snake_case)]
#[no_mangle]
pub fn Java_com_example_rust_TestPathAndResult_do_1testHandArrayReturn(env: *mut JNIEnv,
                                                                  _: jclass,
                                                                  _: jlong)
                                                                  -> jobjectArray {
    let class_id = ::std::ffi::CString::new("com/example/rust/Boo").unwrap();
    let jcls: jclass = unsafe { (**env).FindClass.unwrap()(env, class_id.as_ptr()) };
    if jcls.is_null() {
        panic!("Can not find class_id {:?}", class_id);
    }
    let n = 10;
    let ret: jobjectArray =
        unsafe { (**env).NewObjectArray.unwrap()(env, n, jcls, ::std::ptr::null_mut()) };
    if ret.is_null() {
        panic!("Can not create object array");
    }

    let field_id = ::std::ffi::CString::new("mNativeObj").unwrap();
    let type_id = ::std::ffi::CString::new("J").unwrap();
    let field_id: jfieldID =
        unsafe { (**env).GetFieldID.unwrap()(env, jcls, field_id.as_ptr(), type_id.as_ptr()) };
    assert!(!field_id.is_null());

    for i in 0..n {
        let elem: jobject = unsafe { (**env).AllocObject.unwrap()(env, jcls) };
        let boo = create_boo();
        boo.borrow_mut().set_a(i);
        unsafe {
            (**env).SetLongField.unwrap()(env,
                                          elem,
                                          field_id,
                                          Box::into_raw(Box::new(boo)) as jlong);
            (**env).SetObjectArrayElement.unwrap()(env, ret, i, elem);
            (**env).DeleteLocalRef.unwrap()(env, elem);
        }
    }
    ret
}

foreigner_class!(class TestInner {
    foreigner_code r#"
    public static final class Inner {
        public final String name;

        Inner(String name) {
            this.name = name;
        }
    }
    public static native Inner getInner();
"#;
});

#[allow(non_snake_case)]
#[no_mangle]
pub fn Java_com_example_rust_TestInner_getInner(env: *mut JNIEnv, _: jclass) -> jobject {
    let class_id = ::std::ffi::CString::new("com/example/rust/TestInner$Inner").unwrap();
    let jcls: jclass = unsafe { (**env).FindClass.unwrap()(env, class_id.as_ptr()) };
    assert!(!jcls.is_null());
    let ret: jobject = unsafe { (**env).AllocObject.unwrap()(env, jcls) };
    assert!(!ret.is_null());
    let str_type_id = ::std::ffi::CString::new("Ljava/lang/String;").unwrap();
    let field_id = ::std::ffi::CString::new("name").unwrap();
    let name_field_id: jfieldID =
        unsafe { (**env).GetFieldID.unwrap()(env, jcls, field_id.as_ptr(), str_type_id.as_ptr()) };
    assert!(!name_field_id.is_null());
    let name = ::std::ffi::CString::new("Boo Boo").unwrap();
    let name = unsafe { (**env).NewStringUTF.unwrap()(env, name.as_ptr()) };
    assert!(!name.is_null());
    unsafe {
        (**env).SetObjectField.unwrap()(env, ret, name_field_id, name);
        if (**env).ExceptionCheck.unwrap()(env) != 0 {
            panic!("Failed to SetObjectField");
        }
    }
    ret
}

#[derive(Clone)]
struct Xyz;

impl Xyz {
    fn zero() -> Xyz {
        Xyz
    }
    fn new(_: f64, _: f64, _: f64) -> Xyz {
        Xyz
    }
}


foreigner_class!(class Xyz {
    constructor Xyz::zero() -> Xyz;
    constructor Xyz::new(_: f64, _: f64, _: f64) -> Xyz;
});


struct TestContainers {
    empty_struct_vec: Vec<Xyz>,
    struct_vec: Vec<Foo>,
    string_vec: Vec<String>,
}

impl Default for TestContainers {
    fn default() -> Self {
        let empty_struct_vec = vec![];
        let struct_vec = vec![Foo::new(1, "1"), Foo::new(2, "2")];
        let string_vec = vec!["The".into(),
                              "was".into(),
                              "a".into(),
                              "young".into(),
                              "lady".into(),
                              "whose".into(),
                              "nose".into()];
        TestContainers {
            empty_struct_vec,
            struct_vec,
            string_vec,
        }
    }
}

impl TestContainers {
    fn get_struct_vec(&self) -> Vec<Foo> {
        self.struct_vec.clone()
    }
    fn get_empty_struct_vec(&self) -> Vec<Xyz> {
        self.empty_struct_vec.clone()
    }
    fn get_string_vec(&self) -> Vec<String> {
        self.string_vec.clone()
    }
}

foreigner_class!(class TestContainers {
    self_type TestContainers;
    constructor TestContainers::default() -> TestContainers;
    method TestContainers::get_struct_vec(&self) -> Vec<Foo>;
    method TestContainers::get_empty_struct_vec(&self) -> Vec<Xyz>;
    method TestContainers::get_string_vec(&self) -> Vec<String>;
});

foreigner_class!(class OneStaticFunctionTest {
    static_method f_hypot(_ :f64, _: f64) -> f64;
});
