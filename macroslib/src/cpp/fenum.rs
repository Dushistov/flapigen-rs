use std::{io::Write, path::Path};

use crate::{
    cpp::{cpp_code, map_write_err, CppContext},
    error::Result,
    file_cache::FileWriteCache,
    types::ForeignEnumInfo,
};
use quote::quote;

pub(in crate::cpp) fn generate_c_code_for_enum(
    output_dir: &Path,
    enum_info: &ForeignEnumInfo,
) -> std::result::Result<(), String> {
    let c_path = output_dir.join(cpp_code::cpp_header_name_for_enum(enum_info));
    let mut file = FileWriteCache::new(&c_path);
    let enum_doc_comments = cpp_code::doc_comments_to_c_comments(&enum_info.doc_comments, true);

    write!(
        file,
        r#"// Automaticaly generated by rust_swig
#pragma once

{doc_comments}
enum {enum_name} {{
"#,
        enum_name = enum_info.name,
        doc_comments = enum_doc_comments,
    )
    .map_err(&map_write_err)?;

    for (i, item) in enum_info.items.iter().enumerate() {
        writeln!(
            file,
            "{doc_comments}{item_name} = {index}{separator}",
            item_name = item.name,
            index = i,
            doc_comments = cpp_code::doc_comments_to_c_comments(&item.doc_comments, false),
            separator = if i == enum_info.items.len() - 1 {
                "\n"
            } else {
                ","
            },
        )
        .map_err(&map_write_err)?;
    }

    writeln!(file, "}};").map_err(&map_write_err)?;
    file.update_file_if_necessary().map_err(&map_write_err)?;
    Ok(())
}

pub(in crate::cpp) fn generate_rust_trait_for_enum(
    ctx: &mut CppContext,
    enum_info: &ForeignEnumInfo,
) -> Result<()> {
    let mut arms_to_u32 = Vec::with_capacity(enum_info.items.len());
    let mut arms_from_u32 = Vec::with_capacity(enum_info.items.len());
    assert!((enum_info.items.len() as u64) <= u64::from(u32::max_value()));
    for (i, item) in enum_info.items.iter().enumerate() {
        let item_name = &item.rust_name;
        let idx = i as u32;
        arms_to_u32.push(quote! { #item_name => #idx });
        arms_from_u32.push(quote! { #idx => #item_name });
    }

    let rust_enum_name = &enum_info.name;

    ctx.rust_code.push(quote! {
        impl SwigForeignEnum for #rust_enum_name {
            fn as_u32(&self) -> u32 {
                match *self {
                    #(#arms_to_u32),*
                }
            }
            fn from_u32(x: u32) -> Self {
                match x {
                    #(#arms_from_u32),*
                    ,
                    _ => panic!(concat!("{} not expected for ", stringify!(#rust_enum_name)), x),
                }
            }
        }
    });

    Ok(())
}
