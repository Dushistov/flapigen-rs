use std::{io::Write, path::Path};

use proc_macro2::TokenStream;
use quote::ToTokens;

use crate::{
    cpp::{cpp_code, map_write_err, CppContext},
    error::{panic_on_syn_error, Result},
    file_cache::FileWriteCache,
    source_registry::SourceId,
    typemap::ast::DisplayToTokens,
    types::ForeignEnumInfo,
};

pub(in crate::cpp) fn generate_code_for_enum(
    output_dir: &Path,
    enum_info: &ForeignEnumInfo,
) -> std::result::Result<(), String> {
    let c_path = output_dir.join(cpp_code::cpp_header_name_for_enum(enum_info));
    let mut file = FileWriteCache::new(&c_path);
    let enum_doc_comments = cpp_code::doc_comments_to_c_comments(&enum_info.doc_comments, true);

    write!(
        file,
        r#"// Automaticaly generated by rust_swig
#pragma once

{doc_comments}
enum {enum_name} {{
"#,
        enum_name = enum_info.name,
        doc_comments = enum_doc_comments,
    )
    .map_err(&map_write_err)?;

    for (i, item) in enum_info.items.iter().enumerate() {
        writeln!(
            file,
            "{doc_comments}{item_name} = {index}{separator}",
            item_name = item.name,
            index = i,
            doc_comments = cpp_code::doc_comments_to_c_comments(&item.doc_comments, false),
            separator = if i == enum_info.items.len() - 1 {
                "\n"
            } else {
                ","
            },
        )
        .map_err(&map_write_err)?;
    }

    writeln!(file, "}};").map_err(&map_write_err)?;
    file.update_file_if_necessary().map_err(&map_write_err)?;
    Ok(())
}

pub(in crate::cpp) fn generate_rust_code_for_enum(
    ctx: &mut CppContext,
    enum_info: &ForeignEnumInfo,
) -> Result<Vec<TokenStream>> {
    use std::fmt::Write;

    let rust_enum_name = enum_info.rust_enum_name();

    let mut code = format!(
        r#"
impl SwigFrom<u32> for {rust_enum_name} {{
    fn swig_from(x: u32) -> {rust_enum_name} {{
        match x {{

"#,
        rust_enum_name = rust_enum_name,
    );
    for (i, item) in enum_info.items.iter().enumerate() {
        writeln!(
            &mut code,
            "{index} => {item_name},",
            index = i,
            item_name = DisplayToTokens(&item.rust_name)
        )
        .unwrap();
    }
    write!(
        &mut code,
        r#"
        _ => panic!("{{}} not expected for {rust_enum_name}", x),
        }}
    }}
}}
"#,
        rust_enum_name = rust_enum_name,
    )
    .unwrap();

    write!(
        &mut code,
        r#"
impl SwigFrom<Option<u32>> for Option<{rust_enum_name}> {{
    fn swig_from(x: Option<u32>) -> Option<{rust_enum_name}> {{
        x.map(|v| match v {{

"#,
        rust_enum_name = rust_enum_name,
    )
    .unwrap();
    for (i, item) in enum_info.items.iter().enumerate() {
        writeln!(
            &mut code,
            "{index} => {item_name},",
            index = i,
            item_name = DisplayToTokens(&item.rust_name)
        )
        .unwrap();
    }
    write!(
        &mut code,
        r#"
        _ => panic!("{{}} not expected for {rust_enum_name}", v),
        }})
    }}
}}
"#,
        rust_enum_name = rust_enum_name,
    )
    .unwrap();

    let mut trait_impl = format!(
        r#"
impl SwigForeignEnum for {rust_enum_name} {{
    fn as_u32(&self) -> u32 {{
        match *self {{
"#,
        rust_enum_name = rust_enum_name
    );
    for (i, item) in enum_info.items.iter().enumerate() {
        write!(
            &mut trait_impl,
            r#"
            {item_name} => {index},
"#,
            index = i,
            item_name = DisplayToTokens(&item.rust_name)
        )
        .unwrap();
    }
    write!(
        &mut trait_impl,
        r#"
        }}
    }}
}}
"#
    )
    .unwrap();

    let trait_impl: syn::Item = syn::parse_str(&trait_impl)
        .unwrap_or_else(|err| panic_on_syn_error("trait_impl", trait_impl, err));

    write!(
        &mut code,
        r#"
mod swig_foreign_types_map {{
    #![swig_foreigner_type = "{enum_name}"]
    #![swig_rust_type = "{rust_enum_name}"]
}}

impl SwigFrom<{rust_enum_name}> for u32 {{
   fn swig_from(x: {rust_enum_name}) -> u32 {{
       x.as_u32()
   }}
}}
"#,
        enum_name = enum_info.name,
        rust_enum_name = rust_enum_name,
    )
    .unwrap();

    write!(
        &mut code,
        r#"
impl SwigFrom<Option<{rust_enum_name}>> for Option<u32> {{
   fn swig_from(x: Option<{rust_enum_name}>) -> Option<u32> {{
        x.map(|v| match v {{
"#,
        rust_enum_name = rust_enum_name,
    )
    .unwrap();

    for (i, item) in enum_info.items.iter().enumerate() {
        write!(
            &mut code,
            r#"
           {item_name} => {index},
"#,
            index = i,
            item_name = DisplayToTokens(&item.rust_name)
        )
        .unwrap();
    }
    write!(
        &mut code,
        r#"
       }})
    }}
}}
"#
    )
    .unwrap();

    ctx.conv_map.register_exported_enum(enum_info);
    ctx.conv_map
        .merge(SourceId::none(), &code, ctx.target_pointer_width)?;
    Ok(vec![trait_impl.into_token_stream()])
}
