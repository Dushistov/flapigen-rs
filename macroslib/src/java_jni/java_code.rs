use std::{fmt, io::Write, path::Path};

use bitflags::bitflags;
use rustc_hash::FxHashSet;
use smol_str::SmolStr;

use crate::{
    file_cache::FileWriteCache,
    java_jni::{method_name, JniForeignMethodSignature, NullAnnotation},
    namegen::new_unique_name,
    typemap::{ast::if_result_return_ok_err_types, TypeMap, FROM_VAR_TEMPLATE, TO_VAR_TEMPLATE},
    types::{ForeignEnumInfo, ForeignInterface, ForeignerClassInfo, MethodAccess, MethodVariant},
    WRITE_TO_MEM_FAILED_MSG,
};

bitflags! {
    struct ArgsFormatFlags: u8 {
        const NONE = 0;
        const USE_COMMA_IF_NEED = 1;
        const EXTERNAL = 2;
        const INTERNAL = 4;
        const COMMA_BEFORE = 8;
    }
}

pub(in crate::java_jni) fn generate_java_code_for_enum(
    output_dir: &Path,
    package_name: &str,
    enum_info: &ForeignEnumInfo,
) -> Result<(), String> {
    let path = output_dir.join(format!("{}.java", enum_info.name));
    let mut file = FileWriteCache::new(&path);
    let enum_doc_comments = doc_comments_to_java_comments(&enum_info.doc_comments, true);
    write!(
        file,
        r#"// Automaticaly generated by rust_swig
package {package_name};

{doc_comments}
public enum {enum_name} {{
"#,
        package_name = package_name,
        enum_name = enum_info.name,
        doc_comments = enum_doc_comments,
    )
    .map_err(&map_write_err)?;

    for (i, item) in enum_info.items.iter().enumerate() {
        writeln!(
            file,
            "{doc_comments}{item_name}({index}){separator}",
            item_name = item.name,
            index = i,
            doc_comments = doc_comments_to_java_comments(&item.doc_comments, false),
            separator = if i == enum_info.items.len() - 1 {
                ';'
            } else {
                ','
            },
        )
        .map_err(&map_write_err)?;
    }

    write!(
        file,
        r#"
    private int value;
    {enum_name}(int value) {{
        this.value = value;
    }}
    public final int getValue() {{ return value; }}
}}
"#,
        enum_name = enum_info.name
    )
    .map_err(&map_write_err)?;

    file.update_file_if_necessary().map_err(&map_write_err)?;
    Ok(())
}

pub(in crate::java_jni) fn generate_java_code_for_interface(
    output_dir: &Path,
    package_name: &str,
    interface: &ForeignInterface,
    methods_sign: &[JniForeignMethodSignature],
    use_null_annotation: Option<&str>,
) -> Result<(), String> {
    let path = output_dir.join(format!("{}.java", interface.name));
    let mut file = FileWriteCache::new(&path);
    let imports = get_null_annotation_imports(use_null_annotation, methods_sign);
    let interface_comments = doc_comments_to_java_comments(&interface.doc_comments, true);
    write!(
        file,
        r#"// Automaticaly generated by rust_swig
package {package_name};
{imports}
{doc_comments}
public interface {interface_name} {{
"#,
        package_name = package_name,
        interface_name = interface.name,
        doc_comments = interface_comments,
        imports = imports,
    )
    .map_err(&map_write_err)?;

    for (method, f_method) in interface.items.iter().zip(methods_sign) {
        write!(
            file,
            r#"
{doc_comments}
    void {method_name}({single_args_with_types});
"#,
            method_name = method.name,
            doc_comments = doc_comments_to_java_comments(&method.doc_comments, false),
            single_args_with_types = args_with_java_types(
                f_method,
                method.arg_names_without_self(),
                ArgsFormatFlags::EXTERNAL,
                use_null_annotation.is_some()
            ),
        )
        .expect(WRITE_TO_MEM_FAILED_MSG);
    }

    write!(
        file,
        r#"
}}
"#,
    )
    .expect(WRITE_TO_MEM_FAILED_MSG);
    file.update_file_if_necessary().map_err(&map_write_err)?;
    Ok(())
}

pub(in crate::java_jni) fn generate_java_code(
    conv_map: &mut TypeMap,
    output_dir: &Path,
    package_name: &str,
    class: &ForeignerClassInfo,
    methods_sign: &[JniForeignMethodSignature],
    null_annotation_package: Option<&str>,
) -> Result<(), String> {
    let path = output_dir.join(format!("{}.java", class.name));
    let mut file = FileWriteCache::new(&path);

    let imports = get_null_annotation_imports(null_annotation_package, methods_sign);

    let class_doc_comments = doc_comments_to_java_comments(&class.doc_comments, true);
    write!(
        file,
        r#"// Automaticaly generated by rust_swig
package {package_name};
{imports}
{doc_comments}
public final class {class_name} {{
"#,
        package_name = package_name,
        imports = imports,
        class_name = class.name,
        doc_comments = class_doc_comments,
    )
    .map_err(&map_write_err)?;

    let mut have_methods = false;
    let mut have_constructor = false;

    for (method, f_method) in class.methods.iter().zip(methods_sign) {
        write!(
            &mut file,
            "{doc_comments}",
            doc_comments = doc_comments_to_java_comments(&method.doc_comments, false)
        )
        .expect(WRITE_TO_MEM_FAILED_MSG);

        let may_return_error = match method.fn_decl.output {
            syn::ReturnType::Default => false,
            syn::ReturnType::Type(_, ref ptype) => {
                let ret_rust_ty = conv_map.find_or_alloc_rust_type(ptype, class.src_id);
                if_result_return_ok_err_types(&ret_rust_ty).is_some()
            }
        };

        let exception_spec = if may_return_error {
            " throws Exception"
        } else {
            ""
        };

        let method_access = match method.access {
            MethodAccess::Private => "private",
            MethodAccess::Public => "public",
            MethodAccess::Protected => unreachable!(),
        };
        let conv_code_flags = match method.variant {
            MethodVariant::StaticMethod => ArgsFormatFlags::INTERNAL,
            MethodVariant::Method(_) => ArgsFormatFlags::COMMA_BEFORE | ArgsFormatFlags::INTERNAL,
            MethodVariant::Constructor => ArgsFormatFlags::INTERNAL,
        };
        let known_names: FxHashSet<SmolStr> =
            method.arg_names_without_self().map(|x| x.into()).collect();
        let (convert_code, args_for_call_internal) = convert_code_for_method(
            f_method,
            method.arg_names_without_self(),
            known_names,
            conv_code_flags,
        );
        let func_name = method_name(method, f_method);

        let external_args_except_self = args_with_java_types(
            f_method,
            method.arg_names_without_self(),
            ArgsFormatFlags::EXTERNAL,
            null_annotation_package.is_some(),
        );

        match method.variant {
            MethodVariant::StaticMethod => {
                let ret_type = &f_method.output.name;
                let (native, end) = if convert_code.is_empty() {
                    ("native ", ";\n")
                } else {
                    ("", " {\n")
                };
                write!(
                    file,
                    r#"
    {method_access} static {native}{ret_type} {func_name}({args_with_types}){exception_spec}{end}"#,
                    method_access = method_access,
                    ret_type = ret_type,
                    func_name = method.short_name(),
                    args_with_types = external_args_except_self,
                    exception_spec = exception_spec,
                    native = native,
                    end = end,
                )
                .expect(WRITE_TO_MEM_FAILED_MSG);

                if !convert_code.is_empty() {
                    write!(
                        file,
                        r#"{convert_code}
        {return_code}{func_name}({args});
    }}
    private static native {ret_type} {func_name}({args_with_types}){exception_spec};
"#,
                        ret_type = ret_type,
                        func_name = func_name,
                        return_code = if ret_type != "void" { "return " } else { "" },
                        args_with_types = args_with_java_types(
                            f_method,
                            method.arg_names_without_self(),
                            ArgsFormatFlags::INTERNAL,
                            null_annotation_package.is_some()
                        ),
                        exception_spec = exception_spec,
                        convert_code = convert_code,
                        args = args_for_call_internal,
                    )
                    .expect(WRITE_TO_MEM_FAILED_MSG);
                }
            }
            MethodVariant::Method(_) => {
                have_methods = true;
                let ret_type = &f_method.output.name;
                write!(
                    file,
                    r#"
    {method_access} final {ret_type} {method_name}({single_args_with_types}){exception_spec} {{
{convert_code}
        {return_code}{func_name}(mNativeObj{args});
    }}
    private static native {ret_type} {func_name}(long self{args_with_types}){exception_spec};
"#,
                    method_access = method_access,
                    ret_type = ret_type,
                    method_name = method.short_name(),
                    exception_spec = exception_spec,
                    return_code = if ret_type != "void" { "return " } else { "" },
                    func_name = func_name,
                    convert_code = convert_code,
                    single_args_with_types = external_args_except_self,
                    args_with_types = args_with_java_types(
                        f_method,
                        method.arg_names_without_self(),
                        ArgsFormatFlags::USE_COMMA_IF_NEED | ArgsFormatFlags::INTERNAL,
                        null_annotation_package.is_some()
                    ),
                    args = args_for_call_internal,
                )
                .expect(WRITE_TO_MEM_FAILED_MSG);
            }
            MethodVariant::Constructor => {
                have_constructor = true;

                if method.is_dummy_constructor() {
                    write!(
                        file,
                        "
    {method_access} {class_name}() {{}}
",
                        method_access = method_access,
                        class_name = class.name,
                    )
                    .expect(WRITE_TO_MEM_FAILED_MSG);
                } else {
                    write!(
                        file,
                        "
    {method_access} {class_name}({ext_args_with_types}){exception_spec} {{
{convert_code}
        mNativeObj = init({args});
    }}
    private static native long {func_name}({args_with_types}){exception_spec};
",
                        method_access = method_access,
                        class_name = class.name,
                        exception_spec = exception_spec,
                        func_name = func_name,
                        ext_args_with_types = external_args_except_self,
                        args_with_types = args_with_java_types(
                            f_method,
                            method.arg_names_without_self(),
                            ArgsFormatFlags::INTERNAL,
                            null_annotation_package.is_some()
                        ),
                        convert_code = convert_code,
                        args = args_for_call_internal,
                    )
                    .expect(WRITE_TO_MEM_FAILED_MSG);
                }
            }
        }
    }

    if have_methods && !have_constructor {
        return Err(format!(
            "package {}, class {}: has methods, but no constructor\n
May be you need to use `private constructor = empty;` syntax?",
            package_name, class.name
        ));
    }
    if have_constructor {
        write!(
            file,
            "
    public synchronized void delete() {{
        if (mNativeObj != 0) {{
            do_delete(mNativeObj);
            mNativeObj = 0;
       }}
    }}
    @Override
    protected void finalize() throws Throwable {{
        try {{
            delete();
        }}
        finally {{
             super.finalize();
        }}
    }}
    private static native void do_delete(long me);
    /*package*/ long mNativeObj;
"
        )
        .map_err(&map_write_err)?;
    }

    //utility class, so add private constructor
    //to prevent object creation
    if !have_constructor && !have_methods {
        write!(
            file,
            r#"
    private {class_name}() {{}}
"#,
            class_name = class.name
        )
        .map_err(&map_write_err)?;
    }

    file.write_all(class.foreigner_code.as_bytes())
        .expect(WRITE_TO_MEM_FAILED_MSG);
    write!(file, "}}").expect(WRITE_TO_MEM_FAILED_MSG);

    file.update_file_if_necessary().map_err(&map_write_err)?;
    Ok(())
}

fn args_with_java_types<'a, NI: Iterator<Item = &'a str>>(
    method: &JniForeignMethodSignature,
    arg_name_iter: NI,
    flags: ArgsFormatFlags,
    use_null_annotation: bool,
) -> String {
    use std::fmt::Write;

    assert!(flags.contains(ArgsFormatFlags::INTERNAL) || flags.contains(ArgsFormatFlags::EXTERNAL));

    let mut res = String::new();
    if flags.contains(ArgsFormatFlags::USE_COMMA_IF_NEED) && !method.input.is_empty() {
        res.push_str(", ");
    }
    let external = flags.contains(ArgsFormatFlags::EXTERNAL);

    for (i, (arg, arg_name)) in method.input.iter().zip(arg_name_iter).enumerate() {
        let type_name = match arg.java_converter.as_ref() {
            Some(converter) if flags.contains(ArgsFormatFlags::INTERNAL) => {
                &converter.java_transition_type
            }
            _ => arg.as_ref().name.as_str(),
        };
        let annotation = match arg.annotation {
            Some(NullAnnotation::NonNull) if external && use_null_annotation => "@NonNull ",
            Some(NullAnnotation::Nullable) if external && use_null_annotation => "@Nullable ",
            _ => "",
        };
        if i == (method.input.len() - 1) {
            write!(&mut res, "{}{} {}", annotation, type_name, arg_name)
        } else {
            write!(&mut res, "{}{} {}, ", annotation, type_name, arg_name)
        }
        .expect(WRITE_TO_MEM_FAILED_MSG);
    }
    res
}

fn convert_code_for_method<'a, NI: Iterator<Item = &'a str>>(
    f_method: &JniForeignMethodSignature,
    arg_name_iter: NI,
    mut known_names: FxHashSet<SmolStr>,
    flags: ArgsFormatFlags,
) -> (String, String) {
    let mut conv_code = String::new();
    let mut args_for_call_internal = String::new();

    if flags.contains(ArgsFormatFlags::COMMA_BEFORE) && !f_method.input.is_empty() {
        args_for_call_internal.push_str(", ");
    }

    for (i, (arg, arg_name)) in f_method.input.iter().zip(arg_name_iter).enumerate() {
        let after_conv_arg_name =
            if let Some(code) = arg.java_converter.as_ref().map(|x| &x.converter) {
                let templ = format!("a{}", i);
                let after_conv_arg_name = new_unique_name(&known_names, &templ);
                known_names.insert(after_conv_arg_name.clone());
                let java_code = code
                    .replace(TO_VAR_TEMPLATE, &after_conv_arg_name)
                    .replace(FROM_VAR_TEMPLATE, arg_name);
                conv_code.push_str(&java_code);
                Some(after_conv_arg_name)
            } else {
                None
            };
        if let Some(after_conv_arg_name) = after_conv_arg_name {
            args_for_call_internal.push_str(&after_conv_arg_name);
        } else {
            args_for_call_internal.push_str(arg_name);
        }
        if i != (f_method.input.len() - 1) {
            args_for_call_internal.push_str(", ");
        }
    }
    (conv_code, args_for_call_internal)
}

fn doc_comments_to_java_comments(doc_comments: &[String], class_comments: bool) -> String {
    use std::fmt::Write;
    let mut comments = String::new();
    for (i, comment) in doc_comments.iter().enumerate() {
        if i != 0 {
            comments.push('\n');
        }
        if !class_comments {
            comments.push_str("    ");
        }
        if i == 0 {
            comments.push_str("/**\n");
            if !class_comments {
                comments.push_str("    ");
            }
        }

        write!(&mut comments, " * {}", comment.trim()).unwrap();

        if i == doc_comments.len() - 1 {
            comments.push('\n');
            if !class_comments {
                comments.push_str("    ");
            }
            comments.push_str(" */");
        }
    }
    comments
}

fn get_null_annotation_imports(
    null_annotation_package: Option<&str>,
    methods_sign: &[JniForeignMethodSignature],
) -> String {
    if let Some(null_annotation_package) = null_annotation_package {
        let mut has_non_null = false;
        let mut has_nullable = false;

        for f_method in methods_sign {
            for arg in &f_method.input {
                match arg.annotation {
                    Some(NullAnnotation::NonNull) => has_non_null = true,
                    Some(NullAnnotation::Nullable) => has_nullable = true,
                    _ => {}
                }
                if has_non_null && has_nullable {
                    return format!(
                        "import {package}.NonNull;\nimport {package}.Nullable;\n",
                        package = null_annotation_package
                    );
                }
            }
        }
        if has_non_null {
            return format!(
                "import {package}.NonNull;",
                package = null_annotation_package
            );
        }

        if has_nullable {
            return format!(
                "import {package}.Nullable;\n",
                package = null_annotation_package
            );
        }
    }

    String::new()
}

fn map_write_err<Err: fmt::Display>(err: Err) -> String {
    format!("write failed: {}", err)
}
