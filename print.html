<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>flapigen</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="about.html">About</a></li><li class="chapter-item expanded "><a href="getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cpp-example.html"><strong aria-hidden="true">1.1.</strong> C++</a></li><li class="chapter-item expanded "><a href="java-android-example.html"><strong aria-hidden="true">1.2.</strong> Java/Android</a></li><li class="chapter-item expanded "><a href="java-other-example.html"><strong aria-hidden="true">1.3.</strong> Java/Other</a></li></ol></li><li class="chapter-item expanded "><a href="foreign-lang-api-descr.html"><strong aria-hidden="true">2.</strong> Foreign Language API Description</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="foreign-class.html"><strong aria-hidden="true">2.1.</strong> foreign_class</a></li><li class="chapter-item expanded "><a href="foreign-enum.html"><strong aria-hidden="true">2.2.</strong> foreign_enum</a></li><li class="chapter-item expanded "><a href="foreign-callback.html"><strong aria-hidden="true">2.3.</strong> foreign_callback</a></li><li class="chapter-item expanded "><a href="foreign-typemap.html"><strong aria-hidden="true">2.4.</strong> foreign_typemap</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">flapigen</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><code>flapigen</code> is tool for connecting programs or libraries written in Rust with other languages.
Currently implemented support for <code>C++</code> and <code>Java</code>, but you can write support
for any language of your choice.
It is designed to run by cargo during via cargo's <a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">build script</a> mechanism.</p>
<p>At first you choose what part of your Rust API will be "exported" to other programming language,
and how. At the second step in cargo's build script you describe where get API description and where
put resulted Rust and other language code that generated after processing API description.</p>
<p>Cooperation with other programming languages (in general) is done via C API,
so generated Rust's code is wrapper around you code to provide C API.
Generated code in other programming language is the way to make your API
as easy as possible to use in other language.</p>
<div style="break-before: page; page-break-before: always;"></div><p>In the first step you should choose "main" crate that would be the bridge between Rust and other language.
It should have <code>crate-type</code> <code>cdylib</code> or <code>staticlib</code>, see <a href="https://doc.rust-lang.org/reference/linkage.html">suitable Rust book's section</a> for a detailed description.</p>
<p>For example:</p>
<pre><code class="language-toml no_run noplaypen">[lib]
name = "cpp_example_rust_part"
crate-type = ["cdylib"]
</code></pre>
<p>Then you should create <code>build.rs</code> inside this crate.
For example:</p>
<pre><code class="language-rust no_run noplaypen">//build.rs
use flapigen::{CppConfig, CppOptional, CppStrView, CppVariant, LanguageConfig};
use std::{env, path::Path};

fn main() {
    let out_dir = env::var("OUT_DIR").expect("no OUT_DIR, but cargo should provide it");
    //ANCHOR: cpp_config
    let cpp_cfg = CppConfig::new(
        // ANCHOR: cpp_output
        Path::new("..").join("cpp-part").join("rust-api"),
        // ANCHOR_END: cpp_output
        "rust".into(),
    )
    .cpp_optional(CppOptional::Boost)
    .cpp_variant(CppVariant::Boost)
    .cpp_str_view(CppStrView::Boost);
    //ANCHOR_END: cpp_config
    let swig_gen = flapigen::Generator::new(LanguageConfig::CppConfig(cpp_cfg));
    swig_gen.expand(
        "c++-api-for-rust",
        // ANCHOR: rust_input
        Path::new("src/cpp_glue.rs.in"),
        // ANCHOR_END: rust_input

        // ANCHOR: rust_output
        &amp;Path::new(&amp;out_dir).join("cpp_glue.rs"),
        // ANCHOR_END: rust_output
    );
    println!(
        "cargo:rerun-if-changed={}",
        Path::new("src").join("cpp_glue.rs.in").display()
    );
}</code></pre>
<p>Here you instruct <code>flapigen</code> to generate C++/Rust code from "src/cpp_glue.rs.in" as <strong>input</strong>:</p>
<pre><code class="language-rust no_run noplaypen">        Path::new("src/cpp_glue.rs.in"),</code></pre>
<p>and we specify our <strong>output</strong>,
Rust file:</p>
<pre><code class="language-rust no_run noplaypen">        &amp;Path::new(&amp;out_dir).join("cpp_glue.rs"),</code></pre>
<p>directory for C++ files:</p>
<pre><code class="language-rust no_run noplaypen">        Path::new("..").join("cpp-part").join("rust-api"),</code></pre>
<p>You can find a detailed description of code generation in the <a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html#case-study-code-generation">suitable Cargo book section</a>.</p>
<p>Then you should create a file for the "foreign" language API description.
For example:</p>
<pre><code class="language-rust no_run noplaypen">use super::{f2, Foo};

foreign_class!(class Foo {
    self_type Foo;
    constructor Foo::new(_: i32) -&gt; Foo;
    fn Foo::set_field(&amp;mut self, _: i32);
    fn Foo::f(&amp;self, _: i32, _: i32) -&gt; i32;
    fn f2(_: i32) -&gt; i32;
});</code></pre>
<p>And connect the generated code with your crate exactly how as in the <a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html#case-study-code-generation">Cargo book</a> :</p>
<pre><code class="language-rust no_run noplaypen">// src/lib.rs
mod cpp_glue;
pub use crate::cpp_glue::*;</code></pre>
<pre><code class="language-rust no_run noplaypen">// src/cpp_glue.rs
include!(concat!(env!("OUT_DIR"), "/cpp_glue.rs"));</code></pre>
<p>Do not forget to add <code>flapigen</code> as a dependency into <code>[build-dependencies]</code> section of your crate's <code>Cargo.toml</code> file and you are ready to go.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c"><a class="header" href="#c">C++</a></h1>
<p>To run the cpp-example from <a href="https://github.com/Dushistov/flapigen-rs/tree/master/cpp-example">here</a> you
need <a href="https://www.boost.org/">boost</a>, <a href="https://cmake.org/">cmake</a> and a C++11 compatible compiler.</p>
<h2 id="project-structure"><a class="header" href="#project-structure">Project Structure</a></h2>
<p>The projects consists of two parts: <a href="https://github.com/Dushistov/flapigen-rs/tree/master/cpp-example/cpp-part">cpp-part</a>
and <a href="https://github.com/Dushistov/flapigen-rs/tree/master/cpp-example/rust-part">rust-part</a>.
The Rust part is compiled as shared library and linked into executable
described by <a href="https://github.com/Dushistov/flapigen-rs/tree/master/cpp-example/cpp-part/CMakeLists.txt">CMakeLists.txt</a>.
The cpp-part is the main part so its build system (cmake) invokes <code>cargo</code> to build the Rust part.</p>
<h2 id="building"><a class="header" href="#building">Building</a></h2>
<p>It is a normal CMake project, so you can build it as an ordinary CMake project.
By default it requires C++11 and boost, but if your compiler is modern enough
you can use C++17 and then you don't need boost at all.</p>
<p>Just delete all mentions of boost here:</p>
<pre><code class="language-rust no_run noplaypen">// build.rs
    let cpp_cfg = CppConfig::new(
        Path::new("..").join("cpp-part").join("rust-api"),
        "rust".into(),
    )
    .cpp_optional(CppOptional::Boost)
    .cpp_variant(CppVariant::Boost)
    .cpp_str_view(CppStrView::Boost);</code></pre>
<h2 id="the-main-functionality"><a class="header" href="#the-main-functionality">The main functionality</a></h2>
<p>This project demonstrates how to export Rust in the form of a class to C++.</p>
<p>Rust code:</p>
<pre><code class="language-rust no_run noplaypen">// src/lib.rs
pub struct Foo {
    data: i32,
}

impl Foo {
    fn new(val: i32) -&gt; Foo {
        Foo { data: val }
    }

    fn f(&amp;self, a: i32, b: i32) -&gt; i32 {
        self.data + a + b
    }

    fn set_field(&amp;mut self, v: i32) {
        self.data = v;
    }
}</code></pre>
<p>Described as class:</p>
<pre><code class="language-rust no_run noplaypen">// src/cpp_glue.rs.in
use super::{f2, Foo};

foreign_class!(class Foo {
    self_type Foo;
    constructor Foo::new(_: i32) -&gt; Foo;
    fn Foo::set_field(&amp;mut self, _: i32);
    fn Foo::f(&amp;self, _: i32, _: i32) -&gt; i32;
    fn f2(_: i32) -&gt; i32;
});</code></pre>
<p>Usage from C++:</p>
<pre><code class="language-c++ no_run noplaypen">// main.cpp
    Foo foo(5);
    int res = foo.f(1, 2);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="javaandroid"><a class="header" href="#javaandroid">Java/Android</a></h1>
<p><a href="https://github.com/Dushistov/flapigen-rs/tree/master/android-example">This example</a> shows off how to use rust to build a native library from Android
and use it through an automatically generated JNI wrapper.</p>
<p><a href="https://developer.android.com/studio">Android Studio</a> can be used to work with Rust via its <a href="https://intellij-rust.github.io/">Rust plugin</a>.
So it's not a bad idea to integrate invocations of cargo into gradle,
so you can build and run Rust inside an ordinary Java/Kotlin Android application.</p>
<h2 id="project-structure-1"><a class="header" href="#project-structure-1">Project Structure</a></h2>
<p>The file <code>build.rs</code> defines how flapigen generates wrapper code:</p>
<pre><code class="language-rust no_run noplaypen">// build.rs
    let swig_gen = flapigen::Generator::new(LanguageConfig::JavaConfig(
        JavaConfig::new(
            Path::new("app")
                .join("src")
                .join("main")
                .join("java")
                .join("net")
                .join("akaame")
                .join("myapplication"),
            "net.akaame.myapplication".into(),
        )
        .use_null_annotation_from_package("android.support.annotation".into()),
    ))
    .rustfmt_bindings(true);</code></pre>
<p>The file <code>src/lib.rs</code> contains real code that will be invoked from Java:</p>
<pre><code class="language-rust no_run noplaypen">// src/lib.rs
struct Session {
    a: i32,
}

impl Session {
    pub fn new() -&gt; Session {
        #[cfg(target_os = "android")]
        android_logger::init_once(
            android_logger::Config::default()
                .with_max_level(log::LevelFilter::Debug)
                .with_tag("Hello"),
        );
        log_panics::init(); // log panics rather than printing them
        info!("init log system - done");
        Session { a: 2 }
    }

    pub fn add_and1(&amp;self, val: i32) -&gt; i32 {
        self.a + val + 1
    }

    // Greeting with full, no-runtime-cost support for newlines and UTF-8
    pub fn greet(to: &amp;str) -&gt; String {
        format!("Hello {} ✋\nIt's a pleasure to meet you!", to)
    }
}</code></pre>
<p>And the file <code>src/java_glue.rs.in</code> contains descriptions for flapigen to export this API to Java:</p>
<pre><code class="language-rust no_run noplaypen">// src/java_glue.rs.in
foreign_class!(class Session {
    self_type Session;
    constructor Session::new() -&gt; Session;
    fn Session::add_and1(&amp;self, val: i32) -&gt; i32;
    fn Session::greet(to: &amp;str) -&gt; String;
});</code></pre>
<p>Then the <code>app/build.gradle</code> contains rules to invoke <code>cargo</code> to build a shared library from Rust code,
and then build it into apk:</p>
<pre><code class="language-groovy no_run noplaypen">// app/build.gradle
def rustBasePath = ".."
def archTriplets = [
    'armeabi-v7a': 'armv7-linux-androideabi',
    'arm64-v8a': 'aarch64-linux-android',
]

// TODO: only pass --release if buildType is release
archTriplets.each { arch, target -&gt;
    // execute cargo metadata and get path to target directory
    tasks.create(name: "cargo-output-dir-${arch}", description: "Get cargo metadata") {
        new ByteArrayOutputStream().withStream { os -&gt;
            exec {
                commandLine 'cargo', 'metadata', '--format-version', '1'
                workingDir rustBasePath
                standardOutput = os
            }
            def outputAsString = os.toString()
            def json = new groovy.json.JsonSlurper().parseText(outputAsString)

            logger.info("cargo target directory: ${json.target_directory}")
            project.ext.cargo_target_directory = json.target_directory
        }
    }
    // Build with cargo
    tasks.create(name: "cargo-build-${arch}", type: Exec, description: "Building core for ${arch}", dependsOn: "cargo-output-dir-${arch}") {
        workingDir rustBasePath
        commandLine 'cargo', 'build', "--target=${target}", '--release'
    }
    // Sync shared native dependencies
    tasks.create(name: "sync-rust-deps-${arch}", type: Sync, dependsOn: "cargo-build-${arch}") {
        from "${rustBasePath}/src/libs/${arch}"
        include "*.so"
        into "src/main/libs/${arch}"
    }
    // Copy build libs into this app's libs directory
    tasks.create(name: "rust-deploy-${arch}", type: Copy, dependsOn: "sync-rust-deps-${arch}", description: "Copy rust libs for (${arch}) to jniLibs") {
        from "${project.ext.cargo_target_directory}/${target}/release"
        include "*.so"
        into "src/main/libs/${arch}"
    }

    // Hook up tasks to execute before building java
    tasks.withType(JavaCompile) {
        compileTask -&gt; compileTask.dependsOn "rust-deploy-${arch}"
    }
    preBuild.dependsOn "rust-deploy-${arch}"

    // Hook up clean tasks
    tasks.create(name: "clean-${arch}", type: Delete, description: "Deleting built libs for ${arch}", dependsOn: "cargo-output-dir-${arch}") {
        delete fileTree("${project.ext.cargo_target_directory}/${target}/release") {
            include '*.so'
        }
    }
    clean.dependsOn "clean-${arch}"
}
</code></pre>
<h2 id="building-1"><a class="header" href="#building-1">Building</a></h2>
<p>To build the demo, you will need the latest version of Cargo, Android NDK and install the proper Rust toolchain targets:</p>
<pre><code class="language-shell">rustup target add arm-linux-androideabi
rustup target add aarch64-linux-android
</code></pre>
<p>To link Rust code into a shared library you need add the path to the proper clang binary into your <code>PATH</code>
environment variable or change the path to the linker here:</p>
<pre><code class="language-toml">[target.aarch64-linux-android]
linker = "aarch64-linux-android21-clang++"
runner = "./run-on-android.sh"

[target.armv7-linux-androideabi]
linker = "armv7a-linux-androideabi21-clang++"
runner = "./run-on-android.sh"
</code></pre>
<h2 id="invocation"><a class="header" href="#invocation">Invocation</a></h2>
<p>Gradle will take care of building and deploying the Rust sources. Thus, to build
the project in release mode, simply call <code>./gradlew androidRelease</code>.</p>
<p>To build only the rust libraries for a specific target, call cargo as usual, e.g.
<code>cargo build --target arm-linux-androideabi</code>.</p>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<p>It is possible to run Rust unit tests on Android phone via <code>run-on-android.sh</code> script mentioned in <code>.cargo/config</code>,
there are also instrumentation unit tests in Java that invoke Rust code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="javaother"><a class="header" href="#javaother">Java/Other</a></h1>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="foreign-language-api-description"><a class="header" href="#foreign-language-api-description">Foreign Language API Description</a></h1>
<p><code>flapigen</code> provides several methods to describe how your Rust code can be used
from a "foreign" programming language. The main building block is <a href="./foreign-class.html">foreign_class!</a>.
This is the way to describe entities that will be visible for the "foreign language" as classes.
It is also possible to export C-like enums via <a href="./foreign-enum.html">foreign_enum!</a>, plus it is possible to describe the
way to pass a "callback" into your Rust code from the foreign language via <a href="./foreign-callback.html">foreign_callback!</a>.
And of course it is possible to extend or rewrite existing type conversions rules via <a href="./foreign-typemap.html">foreign_typemap!</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="foreign_class"><a class="header" href="#foreign_class">foreign_class!</a></h1>
<p><code>foreign_class!</code> is the way to describe an entity that will be visible for the "foreign language" as a class.</p>
<p>The basic example is:</p>
<pre><code class="language-rust no_run noplaypen">use super::{f2, Foo};

foreign_class!(class Foo {
    self_type Foo;
    constructor Foo::new(_: i32) -&gt; Foo;
    fn Foo::set_field(&amp;mut self, _: i32);
    fn Foo::f(&amp;self, _: i32, _: i32) -&gt; i32;
    fn f2(_: i32) -&gt; i32;
});</code></pre>
<p>Here <code>Foo</code> may be <strong>struct</strong> or <strong>enum</strong> or a more complex type (see below).
The <strong>self_type</strong> can be omitted if there are no <strong>constructor</strong>s and all <strong>fn</strong> do not accept <strong>self</strong>.</p>
<h2 id="self_type"><a class="header" href="#self_type">self_type</a></h2>
<p>The <strong>self_type</strong> is used as a "neat" way to call methods of types inside "smart pointers".
For example sometimes you can not use your <strong>struct</strong> or <strong>enum</strong> explicitly, because of the semantic
of the "foreign language" does not allow it, then you can write:</p>
<pre><code class="language-rust no_run noplaypen">foreign_class!(class CircularDepsA {
    self_type CircularDepsA;
    constructor CircularDepsA::java_new(_: &amp;str) -&gt; Arc&lt;Mutex&lt;CircularDepsA&gt;&gt;;
    fn CircularDepsA::a(&amp;self, b: &amp;CircularDepsB) -&gt; String;
});</code></pre>
<p>And <code>flapigen</code> will be instructed to generate code to call each method listed above
with <code>lock().unwrap().method</code> syntax.</p>
<p>Also maybe you want export a <code>trait</code> implementation as <code>foregin_class</code>.
The <code>flapigen</code> cannot work with <code>Box&lt;Trait&gt;</code>, because it requires unstable/unsafe APIs to
convert the boxed trait into something that can be transferred over the FFI border,
but it can work with <code>Box&lt;Box&lt;Trait&gt;&gt;</code>, so via <strong>self_type</strong> you can represent a boxed trait as class:</p>
<pre><code class="language-rust no_run noplaypen">pub trait Interface {
    fn f(&amp;self, _: i32) -&gt; i32;
    fn set(&amp;mut self, _: i32);
}
struct InterfaceImpl {
    base: i32,
}

impl Interface for InterfaceImpl {
    fn f(&amp;self, x: i32) -&gt; i32 {
        self.base + x
    }
    fn set(&amp;mut self, x: i32) {
        self.base = x;
    }
}

fn create_interface() -&gt; Box&lt;Box&lt;dyn Interface&gt;&gt; {
    Box::new(Box::new(InterfaceImpl { base: 17 }))
}

foreign_class!(class Interface {
    self_type dyn Interface;
    constructor create_interface() -&gt; Box&lt;Box&lt;dyn Interface&gt;&gt;;
    fn Interface::f(&amp;self, _: i32) -&gt; i32;
    fn Interface::set(&amp;mut self, x: i32);
});</code></pre>
<p>Also it should be noted that <code>flapigen</code> generates code that uses "Universal Function Call Syntax",
so methods can be fake methods and declared outside of <strong>impl</strong> blocks:</p>
<pre><code class="language-rust no_run noplaypen">pub struct TestMethodNotMethod;

impl TestMethodNotMethod {
    fn new() -&gt; Self {
        TestMethodNotMethod
    }
}

fn method_not_method(_this: &amp;TestMethodNotMethod) {}

foreign_class!(class TestMethodNotMethod {
    self_type TestMethodNotMethod;
    constructor TestMethodNotMethod::new() -&gt; TestMethodNotMethod;
    fn method_not_method(&amp;self);
});</code></pre>
<h2 id="access-modifiers"><a class="header" href="#access-modifiers">Access modifiers</a></h2>
<p>By default, methods in generated class are public.
You can change access level via protected and private keywords.</p>
<pre><code class="language-rust no_run noplaypen">foreign_class!(
    class Foo {
        self_type Foo;
        constructor Foo::new() -&gt; Foo;
        private constructor Foo::from_int(_: i32) -&gt; Foo;
        private fn Foo::private_f();
        fn Foo::public_f();
        protected fn Foo::protected_f();
    }
);</code></pre>
<h2 id="inline-methods"><a class="header" href="#inline-methods">Inline methods</a></h2>
<p>It is also sometimes convenient to write short methods just inside <code>foreign_class!</code>, for example to add a way to access
fields of a <strong>struct</strong> or to export a result of a Rust macro call:</p>
<pre><code class="language-rust no_run noplaypen">foreign_class!(class TestFnInline {
    fn int_to_str(a: i32) -&gt; String {
        format!("{}", a)
    }
});</code></pre>
<p>To reference <code>self</code> in inline methods you should use the <code>this</code> variable, because the inline method
is not the real one, it is just code block that gets included into the generated code:</p>
<pre><code class="language-rust no_run noplaypen">pub struct Session {
    name: String,
}

foreign_class!(
    #[derive(SmartPtrCopy)]
    class Session {
        self_type Session;
        constructor session_init(name: &amp;str) -&gt; Rc&lt;RefCell&lt;Session&gt;&gt; {
            Rc::new(RefCell::new(Session {
                name: name.into(),
            }))
        }
        fn name(&amp;self) -&gt; &amp;str {
            &amp;this.name
        }
    }
);</code></pre>
<h2 id="methods-aliases"><a class="header" href="#methods-aliases">Methods aliases</a></h2>
<p>Also you can create an alias for a function name:</p>
<pre><code class="language-rust no_run noplaypen">    fn Foo::f(&amp;self, _: i32, _: i32) -&gt; i32;  alias calcF;</code></pre>
<p>So it would be called by path with <strong>fn</strong> in Rust code,
and you can call it via name with <strong>alias</strong> in foreign language.</p>
<p>This may be useful for example if you want to name functions in Java in camel case style,
while you want to use snake case style in Rust.</p>
<h2 id="constructors"><a class="header" href="#constructors">Constructors</a></h2>
<p>Constructors are Rust methods that mapped to constructors in terms of the "foreign" language.
Also constructors, more precisely, the return type of constructors can be used to
ask <code>flapigen</code> to simplify calls of methods, see the self_type section for more details.
Sometimes you need a constructor, but you don't want allow the user to construct objects,
then you can use an empty constructor:</p>
<pre><code class="language-rust no_run noplaypen">foreign_class!(
    class GamepadId {
        self_type GamepadId;
        private constructor = empty;
        fn GamepadId::value(&amp;self) -&gt; usize;
    }
);</code></pre>
<h2 id="foreigner_code"><a class="header" href="#foreigner_code">foreigner_code</a></h2>
<p>flapigen also supports bypassing code generation:</p>
<pre><code class="language-rust no_run noplaypen">foreign_class!(class TestPathAndResult {
    self_type TestPathAndResult;
    constructor TestPathAndResult::empty() -&gt; Result&lt;TestPathAndResult, String&gt;;
    constructor TestPathAndResult::new(path: &amp;Path) -&gt; Result&lt;TestPathAndResult, String&gt;;
    fn TestPathAndResult::get_path(&amp;self) -&gt; String; alias getPath;
    fn TestPathAndResult::get_boo(&amp;self) -&gt; Rc&lt;RefCell&lt;Boo&gt;&gt;; alias getBoo;
    foreign_code "    public int javaFunc() { return 17; }\n";
    foreign_code r#"
    public Boo[] testHandArrayReturn() { return do_testHandArrayReturn(this.mNativeObj); }
    private static native Boo[] do_testHandArrayReturn(long me);
"#;
    fn TestPathAndResult::get_foo_list(&amp;self) -&gt; Vec&lt;Foo&gt;;
    fn TestPathAndResult::get_result_foo_list(generate_err: bool) -&gt; Result&lt;Vec&lt;Foo&gt;, String&gt;;
});</code></pre>
<p>After that you can implement the Java_com_example_TestPathAndResult_do_1testHandArrayReturn
function yourself, useful for when flapigen cannot handle something automatically,
or you want to do something special.</p>
<h2 id="doc-comments"><a class="header" href="#doc-comments">Doc comments</a></h2>
<p>You can also add comments to generated code with Rust doc comments:</p>
<pre><code class="language-rust no_run noplaypen">foreign_class!(
/// Class comment description for Foo.
#[derive(Clone)]
class Foo {
    self_type Foo;
    /// some text about the new function
    ///
    /// ```
    /// some markdown example in the text
    /// ```
    ///
    /// @param val - some number
    /// @param name - more information
    constructor Foo::new(val: i32, name: &amp;str) -&gt; Foo;</code></pre>
<h2 id="derives"><a class="header" href="#derives">Derives</a></h2>
<p>You can use "derive" syntax on the declaration of classes, in a similar way to the usage on "Rust" structs:</p>
<pre><code class="language-rust no_run noplaypen">/// Class comment description for Foo.
#[derive(Clone)]
class Foo {
    self_type Foo;</code></pre>
<p>Usage of derives changes generated code in various ways.
For example, you can use <code>Clone,Copy</code> to force the generation of a copy constructor
and <code>operator=</code> in C++ case.
You can also use <code>camelCaseAliases</code> to change names of all methods to camel case.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="foreign_enum"><a class="header" href="#foreign_enum">foreign_enum!</a></h1>
<p>Through the usage of the <code>foreign_enum!</code> macro you can "export" <code>enum</code>s (<code>C</code> like enum) to a foreign language:</p>
<pre><code class="language-rust no_run noplaypen">#[derive(Clone, Copy)]
enum MyEnum {
    Item1,
    Item2,
    Item3,
}

foreign_enum!(
    enum MyEnum {
        ITEM1 = MyEnum::Item1,
        ITEM2 = MyEnum::Item2,
        ITEM3 = MyEnum::Item3,
    }
);</code></pre>
<p>This allows you to use it as input or output types for <code>foreign_class!</code> methods.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="foreign_callback"><a class="header" href="#foreign_callback">foreign_callback!</a></h1>
<p>You can also use a <code>trait</code> to describe a callback from Rust to Java/C++:</p>
<pre><code class="language-rust no_run noplaypen">trait EnumObserver {
    fn on_state_changed(&amp;self, item: MyEnum, is_ok: bool);
}

foreign_callback!(callback EnumObserver {
    self_type EnumObserver;
    onStateUpdate = EnumObserver::on_state_changed(&amp;self, item: MyEnum, is_ok: bool);
});

foreign_class!(class TestEnumClass {
    self_type Moo;
    constructor Moo::default() -&gt; Moo;
    fn Moo::f1(&amp;mut self, v: MyEnum) -&gt; i32;
    fn Moo::next_enum(v: MyEnum) -&gt; MyEnum;
    fn call_cb(cb: Box&lt;dyn EnumObserver&gt;) {
        let mut state = false;
        for e in &amp;[MyEnum::Item1, MyEnum::Item2, MyEnum::Item3] {
            cb.on_state_changed(*e, state);
            state = !state;
        }
    }
});</code></pre>
<p>As a result of <code>flapigen</code> processing <code>foreign_callback!</code> it generates an <strong>interface</strong> for Java and
an abstract <strong>class</strong> for C++, so you can implement methods in Java/C++ and pass a pointer/reference to Rust,
and for Rust it would be represented as a <strong>trait</strong> implementation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="foreign_typemap"><a class="header" href="#foreign_typemap">foreign_typemap!</a></h1>
<p><code>flapigen</code> works with a <a href="https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)">graph</a> where
vertices are types and edges are conversion rules between types. To extend or rewrite some rules
you can use the <code>foreign_typemap!</code> macro. <strong>WARNING</strong> this syntax is experimental and subject to change.</p>
<p>Let's take a look at an example:</p>
<pre><code class="language-rust no_run noplaypen">foreign_typemap!(
    ($p:r_type) DateTime&lt;Utc&gt; =&gt; jlong {
        $out = $p.timestamp_millis();
    };
    ($p:f_type, option = "NoNullAnnotations", unique_prefix = "/*chrono*/")
        =&gt; "/*chrono*/java.util.Date" "$out = new java.util.Date($p);";
    ($p:f_type, option = "NullAnnotations", unique_prefix = "/*chrono*/")
        =&gt; "/*chrono*/@NonNull java.util.Date" "$out = new java.util.Date($p);";
);</code></pre>
<p>The <code>(r_type)</code> part of the rule describes a conversion from any Rust type to a Rust type that
can cross the FFI (Foreign Function Interface) border.
For example, in the case of connection Rust and C++, types that can cross the FFI border are nearly all primitive types,
plus types marked with <code>repr(C)</code> and some others. After conversion to the type that can cross the FFI border,
you sometimes want to describe how this type should be converted to "foreign" type. This is done with the
<code>(f_type)</code> part of the rule. Returning to our example, first we describe how to convert <code>DateTime&lt;Utc&gt;</code> (Rust type) to
<code>jlong</code> (Rust type). Then we describe how to convert <code>long</code> (Java type) to <code>java.util.Date</code> (Java type).</p>
<p>There is one nuance. As you can see the Java type is called <code>/*chrono*/java.util.Date</code> instead of
just <code>java.util.Date</code>. This is done because you don't want two edges to one vertex in our graph
mentioned above. There is already a rule for <code>std::time::SystemTime</code> (Rust type) to <code>java.util.Date</code> (Java type),
and it is better not have two rules (edges) that lead to the same vertex <code>java.util.Date</code>,
so we create new unique vertex <code>/*chrono*/java.util.Date</code> != <code>java.util.Date</code>.</p>
<p>Almost all parts of <code>foreign_typemap!</code> are optional.
In the example below we define that <code>jlong</code> (Rust type) is corresponding to <code>long</code> (Java type),
and there is no need to convert anything to get <code>long</code> from <code>jlong</code> and vise versa.</p>
<pre><code class="language-rust no_run noplaypen">foreign_typemap!(
    (r_type) jlong;
    (f_type) "long";
);</code></pre>
<p>It is also possible to use <code>foreign_typemap!</code> for generic type conversion.
In the example below we define the rule to convert any Java type that looks like <code>X []</code>
to <code>Vec&lt;T&gt;</code> if type <code>T</code> implements the traits <code>SwigForeignClass + Clone</code>.</p>
<pre><code class="language-rust no_run noplaypen">foreign_typemap!(
    ($p:r_type) &lt;T: SwigForeignClass + Clone&gt; Vec&lt;T&gt; &lt;= internal_aliases::JForeignObjectsArray&lt;T&gt; {
        $out = jobject_array_to_vec_of_objects(env, $p);
    };
    ($p:f_type, option = "NoNullAnnotations") &lt;= "swig_f_type!(T) []";
    ($p:f_type, option = "NullAnnotations")
                  &lt;= "@NonNull swig_f_type!(T, NoNullAnnotations) []";
);</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
