<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>flapigen</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="about.html">About</a></li><li class="chapter-item expanded "><a href="getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cpp-example.html"><strong aria-hidden="true">1.1.</strong> C++</a></li><li class="chapter-item expanded "><a href="java-android-example.html"><strong aria-hidden="true">1.2.</strong> Java/Android</a></li><li class="chapter-item expanded "><a href="java-other-example.html"><strong aria-hidden="true">1.3.</strong> Java/Other</a></li></ol></li><li class="chapter-item expanded "><a href="foreign-lang-api-descr.html"><strong aria-hidden="true">2.</strong> Foreign Language API Description</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="foreign-class.html"><strong aria-hidden="true">2.1.</strong> foreign_class</a></li><li class="chapter-item expanded "><a href="foreign-enum.html"><strong aria-hidden="true">2.2.</strong> foreign_enum</a></li><li class="chapter-item expanded "><a href="foreign-callback.html"><strong aria-hidden="true">2.3.</strong> foreign_callback</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">flapigen</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><code>flapigen</code> is tool for connecting programs or libraries written in Rust with other languages.
Currently implemented support for <code>C++</code> and <code>Java</code>, but you can write support
for any language of your choice.
It is designed to run by cargo during via cargo's <a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">build script</a> mechanism.</p>
<p>At first you choose what part of your Rust API will be &quot;exported&quot; to other programming language,
and how. At the second step in cargo's build script you describe where get API description and where
put resulted Rust and other language code that generated after processing API description.</p>
<p>Cooperation with other programming languages (in general) is done via C API,
so generated Rust's code is wrapper around you code to provide C API.
Generated code in other programming language is the way to make your API
as easy as possible to use in other language.</p>
<p>In the first step you should choose &quot;main&quot; crate that would be bridge between Rust and other language.
It should has <code>crate-type</code> <code>cdylib</code> or <code>staticlib</code>, see <a href="https://doc.rust-lang.org/reference/linkage.html">suitable Rust book's section</a> for detailed description.</p>
<p>For example:</p>
<pre><code class="language-toml no_run noplaypen">[lib]
name = &quot;cpp_example_rust_part&quot;
crate-type = [&quot;cdylib&quot;]
</code></pre>
<p>Then you should create <code>build.rs</code> inside this crate.
For example:</p>
<pre><code class="language-rust no_run noplaypen">//build.rs
use flapigen::{CppConfig, CppOptional, CppStrView, CppVariant, LanguageConfig};
use std::{env, path::Path};

fn main() {
    let out_dir = env::var(&quot;OUT_DIR&quot;).expect(&quot;no OUT_DIR, but cargo should provide it&quot;);
    //ANCHOR: cpp_config
    let cpp_cfg = CppConfig::new(
        // ANCHOR: cpp_output
        Path::new(&quot;..&quot;).join(&quot;cpp-part&quot;).join(&quot;rust-api&quot;),
        // ANCHOR_END: cpp_output
        &quot;rust&quot;.into(),
    )
    .cpp_optional(CppOptional::Boost)
    .cpp_variant(CppVariant::Boost)
    .cpp_str_view(CppStrView::Boost);
    //ANCHOR_END: cpp_config
    let swig_gen = flapigen::Generator::new(LanguageConfig::CppConfig(cpp_cfg));
    swig_gen.expand(
        &quot;c++-api-for-rust&quot;,
        // ANCHOR: rust_input
        Path::new(&quot;src/cpp_glue.rs.in&quot;),
        // ANCHOR_END: rust_input

        // ANCHOR: rust_output
        &amp;Path::new(&amp;out_dir).join(&quot;cpp_glue.rs&quot;),
        // ANCHOR_END: rust_output
    );
    println!(
        &quot;cargo:rerun-if-changed={}&quot;,
        Path::new(&quot;src&quot;).join(&quot;cpp_glue.rs.in&quot;).display()
    );
}
</code></pre>
<p>Here you instruct <code>flapigen</code> to generate C++/Rust code from &quot;src/cpp_glue.rs.in&quot; as <strong>intput</strong>:</p>
<pre><code class="language-rust no_run noplaypen">        Path::new(&quot;src/cpp_glue.rs.in&quot;),
</code></pre>
<p>and we specify our <strong>output</strong>,
Rust file:</p>
<pre><code class="language-rust no_run noplaypen">        &amp;Path::new(&amp;out_dir).join(&quot;cpp_glue.rs&quot;),
</code></pre>
<p>directory for C++ files:</p>
<pre><code class="language-rust no_run noplaypen">        Path::new(&quot;..&quot;).join(&quot;cpp-part&quot;).join(&quot;rust-api&quot;),
</code></pre>
<p>You can find detailed description of code generation in <a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html#case-study-code-generation">suitable Cargo book's section</a>.</p>
<p>Then you should create file for &quot;foreign&quot; language API description.
For example:</p>
<pre><code class="language-rust no_run noplaypen">use super::{f2, Foo};

foreign_class!(class Foo {
    self_type Foo;
    constructor Foo::new(_: i32) -&gt; Foo;
    fn Foo::set_field(&amp;mut self, _: i32);
    fn Foo::f(&amp;self, _: i32, _: i32) -&gt; i32;
    fn f2(_: i32) -&gt; i32;
});
</code></pre>
<p>And connect generated code with your crate exactly how described in <a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html#case-study-code-generation">Cargo book</a> :</p>
<pre><code class="language-rust no_run noplaypen">// src/lib.rs
mod cpp_glue;
pub use crate::cpp_glue::*;
</code></pre>
<pre><code class="language-rust no_run noplaypen">// src/cpp_glue.rs
include!(concat!(env!(&quot;OUT_DIR&quot;), &quot;/cpp_glue.rs&quot;));
</code></pre>
<p>Do not forget add <code>flapigen</code> as dependency into <code>[build-dependencies]</code> section of crate's <code>Cargo.toml</code> file and you ready to go.</p>
<h1><a class="header" href="#c" id="c">C++</a></h1>
<p>To run cpp-example from <a href="https://github.com/Dushistov/flapigen-rs/tree/master/cpp-example">here</a> you
need <a href="https://www.boost.org/">boost</a>, <a href="https://cmake.org/">cmake</a> and C++11 compatible compiler.</p>
<h2><a class="header" href="#project-structure" id="project-structure">Project Structure</a></h2>
<p>The projects consists of two parts: <a href="https://github.com/Dushistov/flapigen-rs/tree/master/cpp-example/cpp-part">cpp-part</a>
and <a href="https://github.com/Dushistov/flapigen-rs/tree/master/cpp-example/rust-part">rust-part</a>.
rust-part is compiled as shared library and linked into executable
described by <a href="https://github.com/Dushistov/flapigen-rs/tree/master/cpp-example/cpp-part/CMakeLists.txt">CMakeLists.txt</a>.
cpp-part is main part so its build system (cmake) invokes <code>cargo</code> to build rust-part.</p>
<h2><a class="header" href="#building" id="building">Building</a></h2>
<p>It is normal CMake project, so you can build as ordinary CMake project.
By default it requires C++11 and boost, but if your compiler is modern enough
you can use C++17 and then you no need boost at all.</p>
<p>Just delete all mentions of boost here:</p>
<pre><code class="language-rust no_run noplaypen">// build.rs
    let cpp_cfg = CppConfig::new(
        Path::new(&quot;..&quot;).join(&quot;cpp-part&quot;).join(&quot;rust-api&quot;),
        &quot;rust&quot;.into(),
    )
    .cpp_optional(CppOptional::Boost)
    .cpp_variant(CppVariant::Boost)
    .cpp_str_view(CppStrView::Boost);
</code></pre>
<h2><a class="header" href="#the-main-functionality" id="the-main-functionality">The main functionality</a></h2>
<p>Project demonstrate how export Rust in form of class to C++.</p>
<p>Rust code:</p>
<pre><code class="language-rust no_run noplaypen">// src/lib.rs
pub struct Foo {
    data: i32,
}

impl Foo {
    fn new(val: i32) -&gt; Foo {
        Foo { data: val }
    }

    fn f(&amp;self, a: i32, b: i32) -&gt; i32 {
        self.data + a + b
    }

    fn set_field(&amp;mut self, v: i32) {
        self.data = v;
    }
}
</code></pre>
<p>Described as class:</p>
<pre><code class="language-rust no_run noplaypen">// src/cpp_glue.rs.in
use super::{f2, Foo};

foreign_class!(class Foo {
    self_type Foo;
    constructor Foo::new(_: i32) -&gt; Foo;
    fn Foo::set_field(&amp;mut self, _: i32);
    fn Foo::f(&amp;self, _: i32, _: i32) -&gt; i32;
    fn f2(_: i32) -&gt; i32;
});
</code></pre>
<p>Usage from C++:</p>
<pre><code class="language-c++ no_run noplaypen">// main.cpp
    Foo foo(5);
    int res = foo.f(1, 2);
</code></pre>
<h1><a class="header" href="#javaandroid" id="javaandroid">Java/Android</a></h1>
<p><a href="https://github.com/Dushistov/flapigen-rs/tree/master/android-example">This example</a> shows off how to use rust to build a native library from android
and use it through an automatically generated JNI wrapper.</p>
<p><a href="https://developer.android.com/studio">Android Studio</a> can be used to work with Rust via <a href="https://intellij-rust.github.io/">Rust plugin</a>.
So it is not bad idea to integrate invocation of cargo into gradle,
thus you can build and run android application with Rust inside as ordinary Java/Kotlin application.</p>
<h2><a class="header" href="#project-structure-1" id="project-structure-1">Project Structure</a></h2>
<p>The file <code>build.rs</code> defines how flapigen generates wrapper code:</p>
<pre><code class="language-rust no_run noplaypen">// build.rs
    let swig_gen = flapigen::Generator::new(LanguageConfig::JavaConfig(
        JavaConfig::new(
            Path::new(&quot;app&quot;)
                .join(&quot;src&quot;)
                .join(&quot;main&quot;)
                .join(&quot;java&quot;)
                .join(&quot;net&quot;)
                .join(&quot;akaame&quot;)
                .join(&quot;myapplication&quot;),
            &quot;net.akaame.myapplication&quot;.into(),
        )
        .use_null_annotation_from_package(&quot;android.support.annotation&quot;.into()),
    ))
    .rustfmt_bindings(true);
</code></pre>
<p>The file <code>src/lib.rs</code> contains real code that will be invoked from Java:</p>
<pre><code class="language-rust no_run noplaypen">// src/lib.rs
struct Session {
    a: i32,
}

impl Session {
    pub fn new() -&gt; Session {
        #[cfg(target_os = &quot;android&quot;)]
        android_logger::init_once(
            android_logger::Config::default()
                .with_min_level(log::Level::Debug)
                .with_tag(&quot;Hello&quot;),
        );
        log_panics::init(); // log panics rather than printing them
        info!(&quot;init log system - done&quot;);
        Session { a: 2 }
    }

    pub fn add_and1(&amp;self, val: i32) -&gt; i32 {
        self.a + val + 1
    }

    // Greeting with full, no-runtime-cost support for newlines and UTF-8
    pub fn greet(to: &amp;str) -&gt; String {
        format!(&quot;Hello {} âœ‹\nIt's a pleasure to meet you!&quot;, to)
    }
}
</code></pre>
<p>And the file <code>src/java_glue.rs.in</code> contains description for flapigen how export this API to Java:</p>
<pre><code class="language-rust no_run noplaypen">// src/java_glue.rs.in
foreign_class!(class Session {
    self_type Session;
    constructor Session::new() -&gt; Session;
    fn Session::add_and1(&amp;self, val: i32) -&gt; i32;
    fn Session::greet(to: &amp;str) -&gt; String;
});
</code></pre>
<p>Then the <code>app/build.gradle</code> contains rule how to invokes <code>cargo</code> to build shared library from Rust code,
and then build it into apk:</p>
<pre><code class="language-groovy no_run noplaypen">// app/build.gradle
def rustBasePath = &quot;..&quot;
def archTriplets = [
    'armeabi-v7a': 'armv7-linux-androideabi',
    'arm64-v8a': 'aarch64-linux-android',
]

// TODO: only pass --release if buildType is release
archTriplets.each { arch, target -&gt;
    // execute cargo metadata and get path to target directory
    tasks.create(name: &quot;cargo-output-dir-${arch}&quot;, description: &quot;Get cargo metadata&quot;) {
        new ByteArrayOutputStream().withStream { os -&gt;
            exec {
                commandLine 'cargo', 'metadata', '--format-version', '1'
                workingDir rustBasePath
                standardOutput = os
            }
            def outputAsString = os.toString()
            def json = new groovy.json.JsonSlurper().parseText(outputAsString)

            logger.info(&quot;cargo target directory: ${json.target_directory}&quot;)
            project.ext.cargo_target_directory = json.target_directory
        }
    }
    // Build with cargo
    tasks.create(name: &quot;cargo-build-${arch}&quot;, type: Exec, description: &quot;Building core for ${arch}&quot;, dependsOn: &quot;cargo-output-dir-${arch}&quot;) {
        workingDir rustBasePath
        commandLine 'cargo', 'build', &quot;--target=${target}&quot;, '--release'
    }
    // Sync shared native dependencies
    tasks.create(name: &quot;sync-rust-deps-${arch}&quot;, type: Sync, dependsOn: &quot;cargo-build-${arch}&quot;) {
        from &quot;${rustBasePath}/src/libs/${arch}&quot;
        include &quot;*.so&quot;
        into &quot;src/main/libs/${arch}&quot;
    }
    // Copy build libs into this app's libs directory
    tasks.create(name: &quot;rust-deploy-${arch}&quot;, type: Copy, dependsOn: &quot;sync-rust-deps-${arch}&quot;, description: &quot;Copy rust libs for (${arch}) to jniLibs&quot;) {
        from &quot;${project.ext.cargo_target_directory}/${target}/release&quot;
        include &quot;*.so&quot;
        into &quot;src/main/libs/${arch}&quot;
    }

    // Hook up tasks to execute before building java
    tasks.withType(JavaCompile) {
        compileTask -&gt; compileTask.dependsOn &quot;rust-deploy-${arch}&quot;
    }
    preBuild.dependsOn &quot;rust-deploy-${arch}&quot;

    // Hook up clean tasks
    tasks.create(name: &quot;clean-${arch}&quot;, type: Delete, description: &quot;Deleting built libs for ${arch}&quot;, dependsOn: &quot;cargo-output-dir-${arch}&quot;) {
        delete fileTree(&quot;${project.ext.cargo_target_directory}/${target}/release&quot;) {
            include '*.so'
        }
    }
    clean.dependsOn &quot;clean-${arch}&quot;
}
</code></pre>
<h2><a class="header" href="#building-1" id="building-1">Building</a></h2>
<p>To build the demo, you will need the latest version of Cargo, Android NDK and install proper Rust toolchains:</p>
<pre><code class="language-shell">rustup target add arm-linux-androideabi
rustup target add aarch64-linux-android
</code></pre>
<p>To link the result into shared library you need add path to proper clang binary into <code>PATH</code>
environment variable or change path to linker here:</p>
<pre><code class="language-toml">[target.aarch64-linux-android]
linker = &quot;aarch64-linux-android21-clang++&quot;
runner = &quot;./run-on-android.sh&quot;

[target.armv7-linux-androideabi]
linker = &quot;armv7a-linux-androideabi21-clang++&quot;
runner = &quot;./run-on-android.sh&quot;
</code></pre>
<h2><a class="header" href="#invocation" id="invocation">Invocation</a></h2>
<p>Gradle will take care of building and deploying the Rust sources. Thus, to build
the project in release mode, simply call <code>./gradlew androidRelease</code>.</p>
<p>To build only the rust libraries for a specific target, call cargo as usual, e.g.
<code>cargo build --target arm-linux-androideabi</code>.</p>
<h2><a class="header" href="#testing" id="testing">Testing</a></h2>
<p>It is possible to run Rust unit tests on Android phone via <code>run-on-android.sh</code> script mentioned in <code>.cargo/config</code>,
also there is instrumentation unit test on Java that invoke Rust code.</p>
<h1><a class="header" href="#javaother" id="javaother">Java/Other</a></h1>
<p>TODO</p>
<h1><a class="header" href="#foreign-language-api-description" id="foreign-language-api-description">Foreign Language API Description</a></h1>
<p><code>flapigen</code> provides several methods to describe how your Rust code can be used
from &quot;foreign&quot; programming language. The main build block is <code>foreign_class</code>.
This is the way how describe entity that will be visible for &quot;foreign language&quot; as a class.
Also it is possible to export C-like enums via <code>foreign_enum</code>, plus it is possible to describe the
way how to pass &quot;callback&quot; into your Rust code from foreign language.</p>
<h1><a class="header" href="#foreign_class" id="foreign_class">foreign_class!</a></h1>
<p><code>foreign_class!</code> is the way how describe entity that will be visible for &quot;foreign language&quot; as a class.</p>
<p>The basic example is:</p>
<pre><code class="language-rust no_run noplaypen">use super::{f2, Foo};

foreign_class!(class Foo {
    self_type Foo;
    constructor Foo::new(_: i32) -&gt; Foo;
    fn Foo::set_field(&amp;mut self, _: i32);
    fn Foo::f(&amp;self, _: i32, _: i32) -&gt; i32;
    fn f2(_: i32) -&gt; i32;
});
</code></pre>
<p>Here <code>Foo</code> may be <strong>struct</strong> or <strong>enum</strong> or more complex type (see bellow).
The <strong>self_type</strong> can be omitted if there are no <strong>constructor</strong>s and all <strong>fn</strong> do not accept <strong>self</strong>.</p>
<h2><a class="header" href="#self_type" id="self_type">self_type</a></h2>
<p>The <strong>self_type</strong> is used as &quot;neat&quot; way to call methods of types inside &quot;smart pointers&quot;.
For example sometimes you can not use your <strong>struct</strong> or <strong>enum</strong> explicitly, because of semantic
of &quot;foreign language&quot; is not allow it, then you can write:</p>
<pre><code class="language-rust no_run noplaypen">foreign_class!(class CircularDepsA {
    self_type CircularDepsA;
    constructor CircularDepsA::java_new(_: &amp;str) -&gt; Arc&lt;Mutex&lt;CircularDepsA&gt;&gt;;
    fn CircularDepsA::a(&amp;self, b: &amp;CircularDepsB) -&gt; String;
});
</code></pre>
<p>And <code>flapigen</code> will be instructed to generate code to call each method listed above 
with <code>lock().unwrap().method</code> syntax.</p>
<p>Also may be you want export <code>trait</code> implementation as <code>foregin_class</code>.
The <code>flapigen</code> can not work with <code>Box&lt;Trait&gt;</code>, because of it requires unstable/unsafe API to
convert boxed trait to something that can be transferred via FFI border,
but it can work with <code>Box&lt;Box&lt;Trait&gt;&gt;</code>, so via <strong>self_type</strong> you can represent boxed trait as class:</p>
<pre><code class="language-rust no_run noplaypen">pub trait Interface {
    fn f(&amp;self, _: i32) -&gt; i32;
    fn set(&amp;mut self, _: i32);
}
struct InterfaceImpl {
    base: i32,
}

impl Interface for InterfaceImpl {
    fn f(&amp;self, x: i32) -&gt; i32 {
        self.base + x
    }
    fn set(&amp;mut self, x: i32) {
        self.base = x;
    }
}

fn create_interface() -&gt; Box&lt;Box&lt;dyn Interface&gt;&gt; {
    Box::new(Box::new(InterfaceImpl { base: 17 }))
}

foreign_class!(class Interface {
    self_type dyn Interface;
    constructor create_interface() -&gt; Box&lt;Box&lt;dyn Interface&gt;&gt;;
    fn Interface::f(&amp;self, _: i32) -&gt; i32;
    fn Interface::set(&amp;mut self, x: i32);
});
</code></pre>
<p>Also that should be noted that <code>flapigen</code> generates code that uses &quot;Universal Function Call Syntax&quot;,
so method can be not real methods and declared outside of <strong>impl</strong> blocks:</p>
<pre><code class="language-rust no_run noplaypen">pub struct TestMethodNotMethod;

impl TestMethodNotMethod {
    fn new() -&gt; Self {
        TestMethodNotMethod
    }
}

fn method_not_method(_this: &amp;TestMethodNotMethod) {}

foreign_class!(class TestMethodNotMethod {
    self_type TestMethodNotMethod;
    constructor TestMethodNotMethod::new() -&gt; TestMethodNotMethod;
    fn method_not_method(&amp;self);
});
</code></pre>
<h2><a class="header" href="#inline-methods" id="inline-methods">Inline methods</a></h2>
<p>It is also sometimes convenient to write short methods just inside <code>foreign_class!</code>, for example to add way to access
fields of <strong>struct</strong> or export result of Rust's macros application:</p>
<pre><code class="language-rust no_run noplaypen">foreign_class!(class TestFnInline {
    fn int_to_str(a: i32) -&gt; String {
        format!(&quot;{}&quot;, a)
    }
});
</code></pre>
<p>To reference <code>self</code> in inline methods you should use <code>this</code> name, because of inline method
is not the real one, it is just code block that included into generated code:</p>
<pre><code class="language-rust no_run noplaypen">pub struct Session {
    name: String,
}

foreign_class!(
    #[derive(SmartPtrCopy)]
    class Session {
        self_type Session;
        constructor session_init(name: &amp;str) -&gt; Rc&lt;RefCell&lt;Session&gt;&gt; {
            Rc::new(RefCell::new(Session {
                name: name.into(),
            }))
        }
        fn name(&amp;self) -&gt; &amp;str {
            &amp;this.name
        }
    }
);
</code></pre>
<h2><a class="header" href="#methods-aliases" id="methods-aliases">Methods aliases</a></h2>
<p>Also you can create alias for function name:</p>
<pre><code class="language-rust no_run noplaypen">    fn Foo::f(&amp;self, _: i32, _: i32) -&gt; i32;  alias calcF;
</code></pre>
<p>So it would be called by path after <strong>fn</strong> in Rust code,
and you can call it via name after <strong>alias</strong> in foreign language.</p>
<p>May be useful for example if you want name functions in Java in camel case style,
while want in Rust use snake case style.</p>
<h2><a class="header" href="#foreigner_code" id="foreigner_code">foreigner_code</a></h2>
<p>Also flapigen support bypassing of code generation:</p>
<pre><code class="language-rust no_run noplaypen">foreign_class!(class TestPathAndResult {
    self_type TestPathAndResult;
    constructor TestPathAndResult::empty() -&gt; Result&lt;TestPathAndResult, String&gt;;
    constructor TestPathAndResult::new(path: &amp;Path) -&gt; Result&lt;TestPathAndResult, String&gt;;
    fn TestPathAndResult::get_path(&amp;self) -&gt; String; alias getPath;
    fn TestPathAndResult::get_boo(&amp;self) -&gt; Rc&lt;RefCell&lt;Boo&gt;&gt;; alias getBoo;
    foreign_code &quot;    public int javaFunc() { return 17; }\n&quot;;
    foreign_code r#&quot;
    public Boo[] testHandArrayReturn() { return do_testHandArrayReturn(this.mNativeObj); }
    private static native Boo[] do_testHandArrayReturn(long me);
&quot;#;
    fn TestPathAndResult::get_foo_list(&amp;self) -&gt; Vec&lt;Foo&gt;;
    fn TestPathAndResult::get_result_foo_list(generate_err: bool) -&gt; Result&lt;Vec&lt;Foo&gt;, String&gt;;
});
</code></pre>
<p>after that you can implement Java_com_example_TestPathAndResult_do_1testHandArrayReturn
function by your self, usefull when flapigen can not handle something automaticaly,
or you want something special.</p>
<h2><a class="header" href="#doc-comments" id="doc-comments">Doc comments</a></h2>
<p>Also you can add comments to generated code with Rust's doc comments:</p>
<pre><code class="language-rust no_run noplaypen">foreign_class!(
/// Class comment description for Foo.
#[derive(Clone)]
class Foo {
    self_type Foo;
    /// some text about the new function
    ///
    /// ```
    /// some markdown example in the text
    /// ```
    ///
    /// @param val - some number
    /// @param name - more information
    constructor Foo::new(val: i32, name: &amp;str) -&gt; Foo;
</code></pre>
<h1><a class="header" href="#foreign_enum" id="foreign_enum">foreign_enum!</a></h1>
<p>With usage of <code>foreign_enum!</code> macro you can &quot;export&quot; <code>enum</code> (<code>C</code> like enum) to foreign language:</p>
<pre><code class="language-rust no_run noplaypen">#[derive(Clone, Copy)]
enum MyEnum {
    Item1,
    Item2,
    Item3,
}

foreign_enum!(
    enum MyEnum {
        ITEM1 = MyEnum::Item1,
        ITEM2 = MyEnum::Item2,
        ITEM3 = MyEnum::Item3,
    }
);
</code></pre>
<p>This allow you can use it as input or output types for <code>foreign_class!</code> methods.</p>
<h1><a class="header" href="#foreign_callback" id="foreign_callback">foreign_callback!</a></h1>
<p>Also you can use <code>trait</code> to describe callback from Rust to Java/C++:</p>
<pre><code class="language-rust no_run noplaypen">trait EnumObserver {
    fn on_state_changed(&amp;self, item: MyEnum, is_ok: bool);
}

foreign_callback!(callback EnumObserver {
    self_type EnumObserver;
    onStateUpdate = EnumObserver::on_state_changed(&amp;self, item: MyEnum, is_ok: bool);
});

foreign_class!(class TestEnumClass {
    self_type Moo;
    constructor Moo::default() -&gt; Moo;
    fn Moo::f1(&amp;mut self, v: MyEnum) -&gt; i32;
    fn Moo::next_enum(v: MyEnum) -&gt; MyEnum;
    fn call_cb(cb: Box&lt;dyn EnumObserver&gt;) {
        let mut state = false;
        for e in &amp;[MyEnum::Item1, MyEnum::Item2, MyEnum::Item3] {
            cb.on_state_changed(*e, state);
            state = !state;
        }
    }
});
</code></pre>
<p>As result of <code>flapigen</code> processing <code>foreign_callback!</code> it generates <strong>interface</strong> for Java and
abstract <strong>class</strong> for C++, so you can implements methods in Java/C++ and pass pointer/reference to Rust,
and for Rust it would be represented as <strong>trait</strong> implementation.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
