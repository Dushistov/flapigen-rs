use std::fmt;

pub enum TestEnum {
    A,
    B,
}

foreign_enum!(enum TestEnum {
    A = TestEnum::A,
    B = TestEnum::B,
});

pub struct TestStaticClass {
}

impl TestStaticClass {
    pub fn print_hello() {
        println!("Hello from rust");
    }

    pub fn print_number(i: i32) {
        println!("print_number: {}", i);
    }

    pub fn print_str(s: &str) {
        println!("print_str: {}", s);
    }

    pub fn print_string(s: String) {
        println!("print_str: {}", s);
    }

    pub fn reverse_enum(e: TestEnum) -> TestEnum {
        match e {
            TestEnum::A => TestEnum::B,
            TestEnum::B => TestEnum::A,
        }
    }

    pub fn call_test_class_print(test_object: &TestClass) {
        test_object.print();
    }

    pub fn add(a: f32, b: f32) -> f32 {
        a + b
    }

    pub fn increment_vec(v: Vec<f32>) -> Vec<f32> {
        v.into_iter().map(|i| i + 1.0).collect()
    }

    pub fn increment_slice(v: &[f32]) -> Vec<f32> {
        v.into_iter().map(|i| i + 1.0).collect()
    }

    pub fn test_result_str_ok() -> Result<(), String> {
        Ok(())
    }

    pub fn test_result_str_err() -> Result<(), String> {
        Err("Test error string".to_owned())
    }

    pub fn test_result_ok() -> Result<i32, TestError> {
        Ok(0)
    }

    pub fn test_result_err() -> Result<i32, TestError> {
        Err(TestError::new())
    }
}

#[derive(Debug, Clone, Copy)]
pub struct TestError {
}

impl TestError {
    pub fn new() -> TestError {
        TestError {}
    }
}

impl fmt::Display for TestError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "TestError struct!")
    }
}

impl std::error::Error for TestError {}

pub struct TestClass {
    i: i32,
}

impl TestClass {
    pub fn new() -> TestClass {
        TestClass {
            i: 0
        }
    }

    pub fn increment(&mut self) {
        self.i += 1;
    }

    pub fn add(&mut self, i: i32) {
        self.i += i;
    }

    pub fn add_ref(&mut self, i: &i32) {
        self.i += *i;
    }

    pub fn maybe_add(&mut self, i: Option<i32>) -> Option<i32> {
        if let Some(i) = i {
            self.i += i;
            Some(self.i)
        } else {
            None
        }
    }

    pub fn print(&self) {
        println!("TestClass::i: {}", self.i);
    }

    pub fn get(&self) -> i32 {
        self.i
    }

    pub fn get_ref(&self) -> &i32 {
        &self.i
    }
}

foreigner_class!(class TestError {
    self_type TestError;
    constructor TestError::new() -> TestError;
    method std::string::ToString::to_string(&self) -> String;
});

foreigner_class!(class TestStaticClass {
    static_method TestStaticClass::print_hello();
    static_method TestStaticClass::print_number(i: i32);
    static_method TestStaticClass::add(a: f32, b: f32) -> f32;
    static_method TestStaticClass::print_str(s: &str);
    static_method TestStaticClass::print_string(s: String);
    static_method TestStaticClass::call_test_class_print(test_object: &TestClass);
    static_method TestStaticClass::reverse_enum(e: TestEnum) -> TestEnum;
    static_method TestStaticClass::increment_vec(v: Vec<f32>) -> Vec<f32>;
    static_method TestStaticClass::increment_slice(v: &[f32]) -> Vec<f32>;
    static_method TestStaticClass::test_result_str_ok() -> Result<(), String>;
    static_method TestStaticClass::test_result_str_err() -> Result<(), String>;
    static_method TestStaticClass::test_result_ok() -> Result<i32, TestError>;
    static_method TestStaticClass::test_result_err() -> Result<i32, TestError>;
});

foreigner_class!(class TestClass {
    self_type TestClass;
    constructor TestClass::new() -> TestClass;
    method TestClass::increment(&mut self);
    method TestClass::print(&self);
    method TestClass::add(&mut self, i: i32);
    method TestClass::add_ref(&mut self, i: &i32);
    method TestClass::get(&self) -> i32;
    method TestClass::get_ref(&self) -> &i32;
    method TestClass::maybe_add(&mut self, i: Option<i32>) -> Option<i32>;
});
